<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>forest fall :: ritual alignment</title>
<style>
  :root{
    --bg:#0b120e;
    --panel:#0f1a13;
    --paper:#101f16;
    --ink:#d7e7d9;
    --muted:#9fb6a4;
    --line:#294034;
    --accent:#7CFFB2;
    --warn:#ffd37c;
    --danger:#ff7c7c;
    --shadow:rgba(0,0,0,.55);
    --radius:14px;
  }
  html,body{height:100%;}
  body{
    margin:0;
    color:var(--ink);
    background:
      radial-gradient(1200px 800px at 10% 0%, rgba(124,255,178,.08), transparent 55%),
      radial-gradient(900px 600px at 90% 10%, rgba(255,211,124,.06), transparent 55%),
      radial-gradient(1200px 900px at 50% 120%, rgba(124,156,255,.05), transparent 60%),
      var(--bg);
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    letter-spacing:.2px;
  }
  .wrap{max-width:920px;margin:0 auto;padding:16px 14px 28px;}
  .title{display:flex;align-items:flex-end;justify-content:space-between;gap:12px;margin:8px 0 12px;}
  .title h1{font-size:18px;line-height:1.1;margin:0;font-weight:800;text-transform:lowercase;}
  .title .sub{font-size:12px;color:var(--muted);margin-top:6px;}
  .panel{
    background:linear-gradient(180deg, rgba(255,255,255,.03), transparent 30%), var(--panel);
    border:1px solid var(--line);
    border-radius:var(--radius);
    box-shadow: 0 12px 30px var(--shadow), 0 0 0 1px rgba(0,0,0,.35) inset;
    overflow:hidden;
    position:relative;
  }
  .panel::before{
    content:"";
    position:absolute;
    inset:0;
    pointer-events:none;
    background: repeating-linear-gradient(
      to bottom,
      rgba(255,255,255,.03),
      rgba(255,255,255,.03) 1px,
      transparent 1px,
      transparent 5px
    );
    opacity:.08;
    mix-blend-mode:overlay;
  }
  .grid-area{display:grid;grid-template-columns: 1fr 260px;gap:12px;padding:12px;position:relative;z-index:1;}
  @media (max-width: 820px){.grid-area{grid-template-columns: 1fr;}}
  .board-wrap{
    background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.15)), var(--paper);
    border:1px solid var(--line);
    border-radius:calc(var(--radius) - 4px);
    padding:10px;
    position:relative;
  }
  .board-header{display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:10px;flex-wrap:wrap;}
  .badge{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding:6px 10px;
    border:1px solid var(--line);
    border-radius:999px;
    background:rgba(0,0,0,.16);
    color:var(--muted);
    font-size:12px;
    user-select:none;
  }
  .badge strong{color:var(--ink);font-weight:800;}
  .board{
    --cell: 44px;
    display:grid;
    grid-template-columns: repeat(8, var(--cell));
    grid-template-rows: repeat(10, var(--cell));
    gap:6px;
    justify-content:center;
    padding:10px;
    border-radius:12px;
    background:
      linear-gradient(180deg, rgba(255,255,255,.03), transparent 20%),
      rgba(0,0,0,.18);
    border:1px solid rgba(255,255,255,.06);
    box-shadow: 0 0 0 1px rgba(0,0,0,.35) inset;
    touch-action: none;
  }
  @media (max-width: 420px){.board{ --cell: 36px; gap:5px; }}
  .cell{
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:26px;
    line-height:1;
    border-radius:10px;
    background:
      radial-gradient(16px 14px at 30% 25%, rgba(255,255,255,.07), transparent 60%),
      rgba(0,0,0,.18);
    border:1px solid rgba(255,255,255,.06);
    box-shadow: 0 0 0 1px rgba(0,0,0,.25) inset;
    user-select:none;
  }
  @media (max-width: 420px){.cell{ font-size:22px; border-radius:9px; }}
  .ghost{opacity:.28;filter:saturate(.9);}
  .active{outline:1px solid rgba(124,255,178,.28);box-shadow: 0 0 0 2px rgba(124,255,178,.08) inset;}
  .match{outline:1px solid rgba(255,211,124,.45);box-shadow: 0 0 0 2px rgba(255,211,124,.10) inset;}
  .side{display:flex;flex-direction:column;gap:12px;}
  .card{
    background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.10)), var(--paper);
    border:1px solid var(--line);
    border-radius:calc(var(--radius) - 4px);
    padding:12px;
  }
  .card h2{margin:0 0 8px;font-size:12px;font-weight:900;text-transform:lowercase;color:var(--muted);letter-spacing:.4px;}
  .kv{display:grid;grid-template-columns: 1fr auto;gap:8px 10px;align-items:center;font-size:13px;}
  .kv .k{color:var(--muted);}
  .kv .v{font-weight:900;}
  .next{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:10px 12px;
    border-radius:12px;
    border:1px dashed rgba(255,255,255,.10);
    background:rgba(0,0,0,.18);
    margin-top:10px;
  }
  .next .piece{font-size:26px;letter-spacing:2px;}
  .log{margin-top:10px;font-size:12px;color:var(--muted);line-height:1.35;}
  .controls{display:grid;grid-template-columns: repeat(3, 1fr);gap:8px;margin-top:10px;}
  .btn{
    appearance:none;
    border:1px solid rgba(255,255,255,.12);
    background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.22));
    color:var(--ink);
    border-radius:12px;
    padding:10px 10px;
    font:inherit;
    font-weight:900;
    letter-spacing:.2px;
    box-shadow: 0 10px 18px rgba(0,0,0,.28);
    cursor:pointer;
    user-select:none;
    -webkit-tap-highlight-color: transparent;
  }
  .btn:active{ transform: translateY(1px); }
  .btn.small{ padding:9px 10px; font-weight:800; font-size:12px; }
  .btn.accent{ border-color: rgba(124,255,178,.35); }
  .btn.warn{ border-color: rgba(255,211,124,.35); }
  .btn.danger{ border-color: rgba(255,124,124,.35); }
  .hint{margin-top:10px;font-size:12px;color:var(--muted);}
  .overlay{
    position:absolute;
    inset:10px;
    border-radius:12px;
    background:rgba(0,0,0,.62);
    border:1px solid rgba(255,255,255,.08);
    display:none;
    align-items:center;
    justify-content:center;
    text-align:center;
    padding:18px;
    backdrop-filter: blur(2px);
  }
  .overlay.show{display:flex;}
  .overlay .box{max-width:420px;}
  .overlay .box h3{margin:0 0 8px;font-size:14px;text-transform:lowercase;letter-spacing:.2px;}
  .overlay .box p{margin:0 0 12px;color:var(--muted);font-size:12px;line-height:1.4;}
  .pulse{
    animation:pulse 420ms ease-out 1;
  }
  @keyframes pulse{
    0%{transform:scale(1);filter:brightness(1);}
    40%{transform:scale(1.01);filter:brightness(1.12);}
    100%{transform:scale(1);filter:brightness(1);}
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="title">
      <div>
        <h1>forest fall :: ritual align</h1>
        <div class="sub">matches do not clear themselves. press <strong>space</strong> or <strong>c</strong> to perform the ritual.</div>
      </div>
      <div class="badge">status: <strong id="statusText">running</strong></div>
    </div>

    <div class="panel">
      <div class="grid-area">
        <div class="board-wrap">
          <div class="board-header">
            <div class="badge">score: <strong id="score">0</strong></div>
            <div class="badge">level: <strong id="level">1</strong></div>
            <div class="badge">cleared: <strong id="clears">0</strong></div>
            <div class="badge">ritual-ready: <strong id="ready">0</strong></div>
          </div>

          <div class="board" id="board" aria-label="forest fall board"></div>

          <div class="overlay" id="overlay" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="box">
              <h3 id="overlayTitle">paused</h3>
              <p id="overlayText">press <strong>p</strong> to resume.</p>
              <div style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
                <button class="btn accent" id="resumeBtn">resume</button>
                <button class="btn danger" id="restartBtn">restart</button>
              </div>
            </div>
          </div>
        </div>

        <aside class="side">
          <div class="card">
            <h2>next specimen</h2>
            <div class="next">
              <div class="badge">incoming</div>
              <div class="piece" id="nextPiece">üçÑ</div>
            </div>
            <div class="log" id="log">
              <div>align 4 of a kind (üçÑ üå≥ üå≤ ü¶å).</div>
              <div>the grove does not self-clean.</div>
              <div>perform ritual: <strong>space</strong> or <strong>c</strong>.</div>
            </div>
          </div>

          <div class="card">
            <h2>controls</h2>
            <div class="kv">
              <div class="k">move</div><div class="v">‚Üê ‚Üí</div>
              <div class="k">rotate</div><div class="v">‚Üë</div>
              <div class="k">soft drop</div><div class="v">‚Üì</div>
              <div class="k">ritual clear</div><div class="v">space / c</div>
              <div class="k">pause</div><div class="v">p</div>
              <div class="k">restart</div><div class="v">r</div>
            </div>

            <div class="controls" aria-label="mobile controls">
              <button class="btn small" id="btnLeft">‚Üê</button>
              <button class="btn small accent" id="btnRotate">rotate</button>
              <button class="btn small" id="btnRight">‚Üí</button>

              <button class="btn small warn" id="btnDown">drop</button>
              <button class="btn small accent" id="btnRitual">ritual</button>
              <button class="btn small" id="btnPause">pause</button>
            </div>

            <div class="hint">mobile: swipe left/right to move, swipe down to drop, tap to rotate, ritual button to clear.</div>
          </div>
        </aside>
      </div>
    </div>
  </div>

<script>
(() => {
  const ROWS = 10;
  const COLS = 8;
  const MATCH_N = 4;
  const EMOJIS = ["üçÑ","üå≥","üå≤","ü¶å"];
  const SHAPES = [
    [[0,1],[1,1],[2,1],[3,1]],
    [[1,1],[2,1],[1,2],[2,2]],
    [[1,1],[0,2],[1,2],[2,2]],
    [[0,1],[0,2],[0,3],[1,3]],
    [[1,1],[1,2],[1,3],[0,3]],
    [[1,1],[2,1],[0,2],[1,2]],
    [[0,1],[1,1],[1,2],[2,2]]
  ];

  const boardEl = document.getElementById("board");
  const scoreEl = document.getElementById("score");
  const levelEl = document.getElementById("level");
  const clearsEl = document.getElementById("clears");
  const readyEl = document.getElementById("ready");
  const nextPieceEl = document.getElementById("nextPiece");
  const overlayEl = document.getElementById("overlay");
  const overlayTitleEl = document.getElementById("overlayTitle");
  const overlayTextEl = document.getElementById("overlayText");
  const resumeBtn = document.getElementById("resumeBtn");
  const restartBtn = document.getElementById("restartBtn");
  const statusText = document.getElementById("statusText");

  const btnLeft = document.getElementById("btnLeft");
  const btnRight = document.getElementById("btnRight");
  const btnDown = document.getElementById("btnDown");
  const btnRotate = document.getElementById("btnRotate");
  const btnRitual = document.getElementById("btnRitual");
  const btnPause = document.getElementById("btnPause");

  let grid = emptyGrid();
  let cells = [];
  let score = 0;
  let clears = 0;
  let level = 1;

  let dropMsBase = 720;
  let dropTimer = 0;
  let lastTs = 0;

  let paused = false;
  let gameOver = false;

  let current = null;
  let next = spawnPiece();

  let ritualMatches = new Set();

  function emptyGrid(){
    return Array.from({length:ROWS}, () => Array.from({length:COLS}, () => null));
  }
  function idx(r,c){ return r*COLS + c; }
  function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }
  function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  function buildBoard(){
    boardEl.innerHTML = "";
    cells = [];
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const d = document.createElement("div");
        d.className = "cell";
        boardEl.appendChild(d);
        cells.push(d);
      }
    }
  }

  function spawnPiece(){
    return {
      x: 2,
      y: 0,
      shape: pick(SHAPES).map(([x,y]) => [x,y]),
      emoji: pick(EMOJIS)
    };
  }
  function clonePiece(p){
    return { x:p.x, y:p.y, emoji:p.emoji, shape: p.shape.map(([x,y])=>[x,y]) };
  }
  function pieceCells(p){
    return p.shape.map(([sx,sy]) => [p.y + sy, p.x + sx]);
  }
  function collides(p){
    for(const [r,c] of pieceCells(p)){
      if(!inBounds(r,c)) return true;
      if(grid[r][c] !== null) return true;
    }
    return false;
  }
  function placePiece(p){
    for(const [r,c] of pieceCells(p)){
      if(inBounds(r,c)) grid[r][c] = p.emoji;
    }
  }

  function rotatePiece(){
    if(!current || paused || gameOver) return;
    const rotated = clonePiece(current);
    rotated.shape = rotated.shape.map(([x,y]) => [y, 3 - x]);
    const kicks = [[0,0],[-1,0],[1,0],[-2,0],[2,0],[0,-1]];
    for(const [kx,ky] of kicks){
      const test = clonePiece(rotated);
      test.x += kx;
      test.y += ky;
      if(!collides(test)){
        current = test;
        return;
      }
    }
  }

  function move(dx,dy){
    if(!current || paused || gameOver) return false;
    const test = clonePiece(current);
    test.x += dx;
    test.y += dy;
    if(!collides(test)){
      current = test;
      return true;
    }
    return false;
  }

  function softDrop(){
    if(!current || paused || gameOver) return;
    if(!move(0,1)) lock();
    else { score += 1; updateHUD(); }
  }

  function lock(){
    placePiece(current);
    ritualMatches = findMatchesN(MATCH_N);
    current = next;
    next = spawnPiece();
    nextPieceEl.textContent = next.emoji;
    if(collides(current)){
      gameOver = true;
      showOverlay("shift ended", "the canopy is full. press restart.");
      statusText.textContent = "game over";
    }
    updateHUD();
  }

  function findMatchesN(matchN){
    const toMark = new Set();
    const dirs = [[0,1],[1,0],[1,1],[1,-1]];
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const v = grid[r][c];
        if(!v) continue;
        for(const [dr,dc] of dirs){
          let ok = true;
          const coords = [];
          for(let k=0;k<matchN;k++){
            const rr = r + dr*k;
            const cc = c + dc*k;
            if(!inBounds(rr,cc) || grid[rr][cc] !== v){ ok = false; break; }
            coords.push([rr,cc]);
          }
          if(ok){
            for(const [rr,cc] of coords) toMark.add(rr + "," + cc);
          }
        }
      }
    }
    return toMark;
  }

  function clearMarked(set){
    if(!set || set.size === 0) return 0;
    for(const key of set){
      const [r,c] = key.split(",").map(Number);
      grid[r][c] = null;
    }
    return set.size;
  }

  function applyGravityOnce(){
    for(let c=0;c<COLS;c++){
      let write = ROWS - 1;
      for(let r=ROWS-1;r>=0;r--){
        const v = grid[r][c];
        if(v !== null){
          if(write !== r){
            grid[write][c] = v;
            grid[r][c] = null;
          }
          write--;
        }
      }
    }
  }

  function ritual(){
    if(paused || gameOver) return;
    ritualMatches = findMatchesN(MATCH_N);
    if(ritualMatches.size === 0){
      boardEl.classList.remove("pulse");
      void boardEl.offsetWidth;
      boardEl.classList.add("pulse");
      return;
    }
    const n = clearMarked(ritualMatches);
    applyGravityOnce();
    clears += n;
    score += 20 * n * n;
    level = 1 + Math.floor(clears / 10);
    ritualMatches = findMatchesN(MATCH_N);
    updateHUD();
  }

  function dropInterval(){
    return Math.max(170, dropMsBase - (level-1)*55);
  }

  function render(){
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const el = cells[idx(r,c)];
        el.textContent = grid[r][c] ?? "";
        el.classList.remove("active","ghost","match");
      }
    }

    for(const key of ritualMatches){
      const [r,c] = key.split(",").map(Number);
      if(inBounds(r,c)){
        cells[idx(r,c)].classList.add("match");
      }
    }

    if(!current) return;

    const ghost = clonePiece(current);
    while(!collides({...ghost, y: ghost.y + 1})) ghost.y += 1;

    for(const [r,c] of pieceCells(ghost)){
      if(inBounds(r,c) && grid[r][c] === null){
        const el = cells[idx(r,c)];
        el.textContent = ghost.emoji;
        el.classList.add("ghost");
      }
    }

    for(const [r,c] of pieceCells(current)){
      if(inBounds(r,c)){
        const el = cells[idx(r,c)];
        el.textContent = current.emoji;
        el.classList.add("active");
      }
    }
  }

  function updateHUD(){
    scoreEl.textContent = String(score);
    clearsEl.textContent = String(clears);
    levelEl.textContent = String(level);
    readyEl.textContent = String(ritualMatches.size);
  }

  function tick(ts){
    if(!lastTs) lastTs = ts;
    const dt = ts - lastTs;
    lastTs = ts;

    if(!paused && !gameOver){
      dropTimer += dt;
      if(dropTimer >= dropInterval()){
        dropTimer = 0;
        if(!move(0,1)) lock();
      }
    }

    render();
    requestAnimationFrame(tick);
  }

  function showOverlay(title, text){
    overlayTitleEl.textContent = title;
    overlayTextEl.innerHTML = text;
    overlayEl.classList.add("show");
    overlayEl.setAttribute("aria-hidden","false");
  }
  function hideOverlay(){
    overlayEl.classList.remove("show");
    overlayEl.setAttribute("aria-hidden","true");
  }
  function setPaused(p){
    if(gameOver) return;
    paused = p;
    statusText.textContent = paused ? "paused" : "running";
    if(paused) showOverlay("paused", "press <strong>p</strong> to resume.");
    else hideOverlay();
  }

  function restart(){
    grid = emptyGrid();
    score = 0; clears = 0; level = 1;
    dropTimer = 0;
    lastTs = 0;
    paused = false;
    gameOver = false;
    statusText.textContent = "running";
    hideOverlay();
    ritualMatches = new Set();
    next = spawnPiece();
    current = spawnPiece();
    nextPieceEl.textContent = next.emoji;
    for(let i=0;i<10 && collides(current);i++) current = spawnPiece();
    updateHUD();
  }

  window.addEventListener("keydown", (e) => {
    const k = e.key;

    if(k.toLowerCase() === "p"){ e.preventDefault(); setPaused(!paused); return; }
    if(k.toLowerCase() === "r"){ e.preventDefault(); restart(); return; }
    if(k.toLowerCase() === "c"){ e.preventDefault(); ritual(); return; }
    if(k === " "){ e.preventDefault(); ritual(); return; }

    if(paused || gameOver) return;

    if(k === "ArrowLeft"){ e.preventDefault(); move(-1,0); }
    else if(k === "ArrowRight"){ e.preventDefault(); move(1,0); }
    else if(k === "ArrowDown"){ e.preventDefault(); softDrop(); }
    else if(k === "ArrowUp"){ e.preventDefault(); rotatePiece(); }
  }, {passive:false});

  const bindPress = (el, fn) => {
    el.addEventListener("pointerdown", (e) => { e.preventDefault(); fn(); }, {passive:false});
  };

  bindPress(btnLeft, () => move(-1,0));
  bindPress(btnRight, () => move(1,0));
  bindPress(btnDown, () => softDrop());
  bindPress(btnRotate, () => rotatePiece());
  bindPress(btnRitual, () => ritual());
  bindPress(btnPause, () => setPaused(!paused));

  resumeBtn.addEventListener("click", () => setPaused(false));
  restartBtn.addEventListener("click", () => restart());

  let touchStart = null;

  boardEl.addEventListener("pointerdown", (e) => {
    if(gameOver) return;
    if(paused){ setPaused(false); return; }
    boardEl.setPointerCapture(e.pointerId);
    touchStart = { x:e.clientX, y:e.clientY, t: performance.now(), moved:false };
  });

  boardEl.addEventListener("pointermove", (e) => {
    if(!touchStart || paused || gameOver) return;
    const dx = e.clientX - touchStart.x;
    const dy = e.clientY - touchStart.y;
    const THX = 22;
    const THY = 26;

    if(Math.abs(dx) > THX && Math.abs(dx) > Math.abs(dy)){
      touchStart.moved = true;
      touchStart.x = e.clientX;
      move(dx > 0 ? 1 : -1, 0);
    } else if(dy > THY && Math.abs(dy) > Math.abs(dx)){
      touchStart.moved = true;
      touchStart.y = e.clientY;
      softDrop();
    }
  });

  boardEl.addEventListener("pointerup", () => {
    if(!touchStart) return;
    const elapsed = performance.now() - touchStart.t;
    if(!touchStart.moved && elapsed < 260 && !paused && !gameOver) rotatePiece();
    touchStart = null;
  });

  document.addEventListener("visibilitychange", () => {
    if(document.hidden && !paused && !gameOver) setPaused(true);
  });

  buildBoard();
  current = spawnPiece();
  next = spawnPiece();
  nextPieceEl.textContent = next.emoji;
  for(let i=0;i<10 && collides(current);i++) current = spawnPiece();
  ritualMatches = findMatchesN(MATCH_N);
  updateHUD();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
