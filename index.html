<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>forest fall :: ritual align</title>
<style>
  :root{
    --bg:#0b120e;
    --panel:#0f1a13;
    --paper:#101f16;
    --ink:#d7e7d9;
    --muted:#9fb6a4;
    --line:#294034;
    --accent:#7CFFB2;
    --warn:#ffd37c;
    --danger:#ff7c7c;
    --shadow:rgba(0,0,0,.55);
    --radius:14px;
  }

  html,body{height:100%;margin:0;}
  body{
    color:var(--ink);
    background:
      radial-gradient(1200px 800px at 10% 0%, rgba(124,255,178,.08), transparent 55%),
      radial-gradient(900px 600px at 90% 10%, rgba(255,211,124,.06), transparent 55%),
      radial-gradient(1200px 900px at 50% 120%, rgba(124,156,255,.05), transparent 60%),
      var(--bg);
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    letter-spacing:.2px;
    display:flex;
    flex-direction:column;
    overflow:hidden;
  }

  html.fs, html.fs body{ overflow:hidden !important; }

  .wrap{
    flex:1;
    display:flex;
    flex-direction:column;
    width:100%;
    max-width:920px;
    margin:0 auto;
    padding:16px 14px 18px;
    box-sizing:border-box;
    min-height:0;
  }

  .title{display:flex;align-items:flex-end;justify-content:space-between;gap:12px;margin:8px 0 12px;}
  .title h1{font-size:18px;line-height:1.1;margin:0;font-weight:800;text-transform:lowercase;}
  .title .sub{font-size:12px;color:var(--muted);margin-top:6px;max-width:72ch;}

  .badge{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding:6px 10px;
    border:1px solid var(--line);
    border-radius:999px;
    background:rgba(0,0,0,.16);
    color:var(--muted);
    font-size:12px;
    user-select:none;
    white-space:nowrap;
  }
  .badge strong{color:var(--ink);font-weight:800;}

  .panel{
    flex:1;
    display:flex;
    flex-direction:column;
    background:linear-gradient(180deg, rgba(255,255,255,.03), transparent 30%), var(--panel);
    border:1px solid var(--line);
    border-radius:var(--radius);
    box-shadow: 0 12px 30px var(--shadow), 0 0 0 1px rgba(0,0,0,.35) inset;
    overflow:hidden;
    position:relative;
    min-height:0;
  }
  .panel::before{
    content:"";
    position:absolute;
    inset:0;
    pointer-events:none;
    background: repeating-linear-gradient(
      to bottom,
      rgba(255,255,255,.03),
      rgba(255,255,255,.03) 1px,
      transparent 1px,
      transparent 5px
    );
    opacity:.08;
    mix-blend-mode:overlay;
  }

  .grid-area{
    flex:1;
    display:grid;
    grid-template-columns: 1fr 260px;
    gap:12px;
    padding:12px;
    position:relative;
    z-index:1;
    min-height:0;
  }

  .board-wrap{
    background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.15)), var(--paper);
    border:1px solid var(--line);
    border-radius:calc(var(--radius) - 4px);
    padding:10px;
    position:relative;
    display:flex;
    flex-direction:column;
    min-height:0;
  }

  .board-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:10px;
    margin-bottom:10px;
    flex-wrap:wrap;
  }

  .board{
    flex:1;
    display:grid;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(10, 1fr);
    gap:6px;
    width:100%;
    min-height:0;
    justify-content:center;
    padding:10px;
    border-radius:12px;
    background:
      linear-gradient(180deg, rgba(255,255,255,.03), transparent 20%),
      rgba(0,0,0,.18);
    border:1px solid rgba(255,255,255,.06);
    box-shadow: 0 0 0 1px rgba(0,0,0,.35) inset;
    touch-action:none;
    box-sizing:border-box;
  }

  .cell{
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:clamp(18px, 2.2vmin, 26px);
    line-height:1;
    border-radius:10px;
    background:
      radial-gradient(16px 14px at 30% 25%, rgba(255,255,255,.07), transparent 60%),
      rgba(0,0,0,.18);
    border:1px solid rgba(255,255,255,.06);
    box-shadow: 0 0 0 1px rgba(0,0,0,.25) inset;
    user-select:none;
  }

  .ghost{opacity:.28;filter:saturate(.9);}
  .active{outline:1px solid rgba(124,255,178,.28);box-shadow: 0 0 0 2px rgba(124,255,178,.08) inset;}
  .match{outline:1px solid rgba(255,211,124,.45);box-shadow: 0 0 0 2px rgba(255,211,124,.10) inset;}

  .side{display:flex;flex-direction:column;gap:12px;min-height:0;}

  .card{
    background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.10)), var(--paper);
    border:1px solid var(--line);
    border-radius:calc(var(--radius) - 4px);
    padding:12px;
  }
  .card h2{margin:0 0 8px;font-size:12px;font-weight:900;text-transform:lowercase;color:var(--muted);letter-spacing:.4px;}

  .kv{display:grid;grid-template-columns: 1fr auto;gap:8px 10px;align-items:center;font-size:13px;}
  .kv .k{color:var(--muted);}
  .kv .v{font-weight:900;}

  .next{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:10px 12px;
    border-radius:12px;
    border:1px dashed rgba(255,255,255,.10);
    background:rgba(0,0,0,.18);
    margin-top:10px;
  }
  .next .piece{font-size:26px;letter-spacing:2px;}

  .log{margin-top:10px;font-size:12px;color:var(--muted);line-height:1.35;}

  .btn{
    appearance:none;
    border:1px solid rgba(255,255,255,.12);
    background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.22));
    color:var(--ink);
    border-radius:12px;
    padding:10px 10px;
    font:inherit;
    font-weight:900;
    letter-spacing:.2px;
    box-shadow: 0 10px 18px rgba(0,0,0,.28);
    cursor:pointer;
    user-select:none;
    -webkit-tap-highlight-color: transparent;
  }
  .btn:active{ transform: translateY(1px); }
  .btn.accent{ border-color: rgba(124,255,178,.35); }
  .btn.danger{ border-color: rgba(255,124,124,.35); }

  .overlay{
    position:absolute;
    inset:10px;
    border-radius:12px;
    background:rgba(0,0,0,.62);
    border:1px solid rgba(255,255,255,.08);
    display:none;
    align-items:center;
    justify-content:center;
    text-align:center;
    padding:18px;
    backdrop-filter: blur(2px);
    z-index:5;
  }
  .overlay.show{display:flex;}
  .overlay .box{max-width:520px;}
  .overlay .box h3{margin:0 0 8px;font-size:14px;text-transform:lowercase;letter-spacing:.2px;}
  .overlay .box p{margin:0 0 12px;color:var(--muted);font-size:12px;line-height:1.4;}
  .overlay .row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;}

  .pulse{animation:pulse 420ms ease-out 1;}
  @keyframes pulse{
    0%{transform:scale(1);filter:brightness(1);}
    40%{transform:scale(1.01);filter:brightness(1.12);}
    100%{transform:scale(1);filter:brightness(1);}
  }

  .desktop-only{
    position:absolute;
    inset:0;
    z-index:20;
    display:none;
    align-items:center;
    justify-content:center;
    padding:18px;
    text-align:center;
    background:rgba(0,0,0,.72);
    backdrop-filter: blur(4px);
  }
  .desktop-only .box{
    max-width:520px;
    background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,.18)), var(--paper);
    border:1px solid rgba(255,255,255,.10);
    border-radius:14px;
    padding:16px;
    box-shadow: 0 18px 40px rgba(0,0,0,.55);
  }
  .desktop-only h3{margin:0 0 8px;font-size:14px;text-transform:lowercase;}
  .desktop-only p{margin:0 0 10px;color:var(--muted);font-size:12px;line-height:1.45;}
  .desktop-only .tiny{opacity:.9;font-size:12px;}
  @media (max-width: 820px){
    .desktop-only{display:flex;}
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="title">
      <div>
        <h1>forest fall :: ritual align</h1>
        <div class="sub">matches do not clear themselves. press <strong>space</strong> or <strong>c</strong> to perform the ritual. start can request fullscreen (esc exits).</div>
      </div>
      <div class="badge">status: <strong id="statusText">idle</strong></div>
    </div>

    <div class="panel">
      <div class="desktop-only" id="desktopOnly">
        <div class="box">
          <h3>desktop only</h3>
          <p>this grove simulation is currently calibrated for keyboards and wide screens.</p>
          <p class="tiny">open on a desktop/laptop browser to play.</p>
        </div>
      </div>

      <div class="grid-area">
        <div class="board-wrap">
          <div class="board-header">
            <div class="badge">score: <strong id="score">0</strong></div>
            <div class="badge">level: <strong id="level">1</strong></div>
            <div class="badge">cleared: <strong id="clears">0</strong></div>
            <div class="badge">ritual-ready: <strong id="ready">0</strong></div>
            <div class="badge">view: <strong id="viewText">window</strong></div>
          </div>

          <div class="board" id="board" aria-label="forest fall board"></div>

          <div class="overlay show" id="startOverlay" role="dialog" aria-modal="true" aria-hidden="false">
            <div class="box">
              <h3>enter the grove</h3>
              <p>tap start. if permitted, the training sim will expand to fullscreen. esc exits.</p>
              <div class="row">
                <button class="btn accent" id="startBtn">start</button>
                <button class="btn" id="startFsBtn">start + fullscreen</button>
              </div>
              <p style="margin-top:12px;">controls: ‚Üê ‚Üí move ¬∑ ‚Üë rotate ¬∑ ‚Üì drop ¬∑ space/c ritual ¬∑ p pause ¬∑ r restart</p>
            </div>
          </div>

          <div class="overlay" id="overlay" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="box">
              <h3 id="overlayTitle">paused</h3>
              <p id="overlayText">press <strong>p</strong> to resume.</p>
              <div class="row">
                <button class="btn accent" id="resumeBtn">resume</button>
                <button class="btn" id="fsBtn">fullscreen</button>
                <button class="btn danger" id="restartBtn">restart</button>
              </div>
            </div>
          </div>
        </div>

        <aside class="side">
          <div class="card">
            <h2>next specimen</h2>
            <div class="next">
              <div class="badge">incoming</div>
              <div class="piece" id="nextPiece">üçÑ</div>
            </div>
            <div class="log">
              <div>align 4 of a kind (üçÑ üå≥ üå≤ ü¶å).</div>
              <div>the grove does not self-clean.</div>
              <div>ritual clear: <strong>space</strong> or <strong>c</strong>.</div>
            </div>
          </div>

          <div class="card">
            <h2>controls</h2>
            <div class="kv">
              <div class="k">move</div><div class="v">‚Üê ‚Üí</div>
              <div class="k">rotate</div><div class="v">‚Üë</div>
              <div class="k">soft drop</div><div class="v">‚Üì</div>
              <div class="k">ritual clear</div><div class="v">space / c</div>
              <div class="k">pause</div><div class="v">p</div>
              <div class="k">restart</div><div class="v">r</div>
            </div>
          </div>
        </aside>
      </div>
    </div>
  </div>

<script>
(() => {
  const ROWS = 10;
  const COLS = 8;
  const MATCH_N = 4;
  const EMOJIS = ["üçÑ","üå≥","üå≤","ü¶å"];
  const SHAPES = [
    [[0,1],[1,1],[2,1],[3,1]],
    [[1,1],[2,1],[1,2],[2,2]],
    [[1,1],[0,2],[1,2],[2,2]],
    [[0,1],[0,2],[0,3],[1,3]],
    [[1,1],[1,2],[1,3],[0,3]],
    [[1,1],[2,1],[0,2],[1,2]],
    [[0,1],[1,1],[1,2],[2,2]]
  ];

  const boardEl = document.getElementById("board");
  const scoreEl = document.getElementById("score");
  const levelEl = document.getElementById("level");
  const clearsEl = document.getElementById("clears");
  const readyEl = document.getElementById("ready");
  const nextPieceEl = document.getElementById("nextPiece");
  const overlayEl = document.getElementById("overlay");
  const overlayTitleEl = document.getElementById("overlayTitle");
  const overlayTextEl = document.getElementById("overlayText");
  const resumeBtn = document.getElementById("resumeBtn");
  const restartBtn = document.getElementById("restartBtn");
  const fsBtn = document.getElementById("fsBtn");
  const statusText = document.getElementById("statusText");
  const viewText = document.getElementById("viewText");

  const startOverlay = document.getElementById("startOverlay");
  const startBtn = document.getElementById("startBtn");
  const startFsBtn = document.getElementById("startFsBtn");

  const desktopOnly = document.getElementById("desktopOnly");

  let grid = emptyGrid();
  let cells = [];
  let score = 0;
  let clears = 0;
  let level = 1;

  let dropMsBase = 720;
  let dropTimer = 0;
  let lastTs = 0;

  let paused = false;
  let gameOver = false;
  let started = false;

  let current = null;
  let next = spawnPiece();
  let ritualMatches = new Set();

  function isMobile(){
    return window.matchMedia("(max-width: 820px)").matches;
  }

  function emptyGrid(){
    return Array.from({length:ROWS}, () => Array.from({length:COLS}, () => null));
  }
  function idx(r,c){ return r*COLS + c; }
  function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }
  function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  function buildBoard(){
    boardEl.innerHTML = "";
    cells = [];
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const d = document.createElement("div");
        d.className = "cell";
        boardEl.appendChild(d);
        cells.push(d);
      }
    }
  }

  function spawnPiece(){
    return {
      x: 2,
      y: 0,
      shape: pick(SHAPES).map(([x,y]) => [x,y]),
      emoji: pick(EMOJIS)
    };
  }
  function clonePiece(p){
    return { x:p.x, y:p.y, emoji:p.emoji, shape: p.shape.map(([x,y])=>[x,y]) };
  }
  function pieceCells(p){
    return p.shape.map(([sx,sy]) => [p.y + sy, p.x + sx]);
  }
  function collides(p){
    for(const [r,c] of pieceCells(p)){
      if(!inBounds(r,c)) return true;
      if(grid[r][c] !== null) return true;
    }
    return false;
  }
  function placePiece(p){
    for(const [r,c] of pieceCells(p)){
      if(inBounds(r,c)) grid[r][c] = p.emoji;
    }
  }

  function rotatePiece(){
    if(!current || paused || gameOver || !started) return;
    const rotated = clonePiece(current);
    rotated.shape = rotated.shape.map(([x,y]) => [y, 3 - x]);
    const kicks = [[0,0],[-1,0],[1,0],[-2,0],[2,0],[0,-1]];
    for(const [kx,ky] of kicks){
      const test = clonePiece(rotated);
      test.x += kx;
      test.y += ky;
      if(!collides(test)){
        current = test;
        return;
      }
    }
  }

  function move(dx,dy){
    if(!current || paused || gameOver || !started) return false;
    const test = clonePiece(current);
    test.x += dx;
    test.y += dy;
    if(!collides(test)){
      current = test;
      return true;
    }
    return false;
  }

  function softDrop(){
    if(!current || paused || gameOver || !started) return;
    if(!move(0,1)) lock();
    else { score += 1; updateHUD(); }
  }

  function lock(){
    placePiece(current);
    ritualMatches = findMatchesN(MATCH_N);
    current = next;
    next = spawnPiece();
    nextPieceEl.textContent = next.emoji;
    if(collides(current)){
      gameOver = true;
      showOverlay("shift ended", "the canopy is full. press restart.");
      statusText.textContent = "game over";
    }
    updateHUD();
  }

  function findMatchesN(matchN){
    const toMark = new Set();
    const dirs = [[0,1],[1,0],[1,1],[1,-1]];
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const v = grid[r][c];
        if(!v) continue;
        for(const [dr,dc] of dirs){
          let ok = true;
          const coords = [];
          for(let k=0;k<matchN;k++){
            const rr = r + dr*k;
            const cc = c + dc*k;
            if(!inBounds(rr,cc) || grid[rr][cc] !== v){ ok = false; break; }
            coords.push([rr,cc]);
          }
          if(ok){
            for(const [rr,cc] of coords) toMark.add(rr + "," + cc);
          }
        }
      }
    }
    return toMark;
  }

  function clearMarked(set){
    if(!set || set.size === 0) return 0;
    for(const key of set){
      const [r,c] = key.split(",").map(Number);
      grid[r][c] = null;
    }
    return set.size;
  }

  function applyGravityOnce(){
    for(let c=0;c<COLS;c++){
      let write = ROWS - 1;
      for(let r=ROWS-1;r>=0;r--){
        const v = grid[r][c];
        if(v !== null){
          if(write !== r){
            grid[write][c] = v;
            grid[r][c] = null;
          }
          write--;
        }
      }
    }
  }

  function ritual(){
    if(paused || gameOver || !started) return;
    ritualMatches = findMatchesN(MATCH_N);
    if(ritualMatches.size === 0){
      boardEl.classList.remove("pulse");
      void boardEl.offsetWidth;
      boardEl.classList.add("pulse");
      updateHUD();
      return;
    }
    const n = clearMarked(ritualMatches);
    applyGravityOnce();
    clears += n;
    score += 20 * n * n;
    level = 1 + Math.floor(clears / 10);
    ritualMatches = findMatchesN(MATCH_N);
    updateHUD();
  }

  function dropInterval(){
    return Math.max(170, dropMsBase - (level-1)*55);
  }

  function render(){
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const el = cells[idx(r,c)];
        el.textContent = grid[r][c] ?? "";
        el.classList.remove("active","ghost","match");
      }
    }

    for(const key of ritualMatches){
      const [r,c] = key.split(",").map(Number);
      if(inBounds(r,c)) cells[idx(r,c)].classList.add("match");
    }

    if(!current || !started) return;

    const ghost = clonePiece(current);
    while(!collides({...ghost, y: ghost.y + 1})) ghost.y += 1;

    for(const [r,c] of pieceCells(ghost)){
      if(inBounds(r,c) && grid[r][c] === null){
        const el = cells[idx(r,c)];
        el.textContent = ghost.emoji;
        el.classList.add("ghost");
      }
    }

    for(const [r,c] of pieceCells(current)){
      if(inBounds(r,c)){
        const el = cells[idx(r,c)];
        el.textContent = current.emoji;
        el.classList.add("active");
      }
    }
  }

  function updateHUD(){
    scoreEl.textContent = String(score);
    clearsEl.textContent = String(clears);
    levelEl.textContent = String(level);
    readyEl.textContent = String(ritualMatches.size);
    viewText.textContent = document.fullscreenElement ? "fullscreen" : "window";
  }

  function tick(ts){
    if(!lastTs) lastTs = ts;
    const dt = ts - lastTs;
    lastTs = ts;

    if(started && !paused && !gameOver){
      dropTimer += dt;
      if(dropTimer >= dropInterval()){
        dropTimer = 0;
        if(!move(0,1)) lock();
      }
    }

    render();
    requestAnimationFrame(tick);
  }

  function showOverlay(title, text){
    overlayTitleEl.textContent = title;
    overlayTextEl.innerHTML = text;
    overlayEl.classList.add("show");
    overlayEl.setAttribute("aria-hidden","false");
  }
  function hideOverlay(){
    overlayEl.classList.remove("show");
    overlayEl.setAttribute("aria-hidden","true");
  }

  function setPaused(p){
    if(gameOver || !started) return;
    paused = p;
    statusText.textContent = paused ? "paused" : "running";
    if(paused) showOverlay("paused", "press <strong>p</strong> to resume.");
    else hideOverlay();
  }

  function restart(){
    grid = emptyGrid();
    score = 0; clears = 0; level = 1;
    dropTimer = 0;
    lastTs = 0;
    paused = false;
    gameOver = false;
    started = true;
    statusText.textContent = "running";
    hideOverlay();
    ritualMatches = new Set();
    next = spawnPiece();
    current = spawnPiece();
    nextPieceEl.textContent = next.emoji;
    for(let i=0;i<10 && collides(current);i++) current = spawnPiece();
    ritualMatches = findMatchesN(MATCH_N);
    updateHUD();
  }

  async function requestFS(){
    try{
      if(!document.fullscreenElement){
        const el = document.documentElement;
        if(el.requestFullscreen) await el.requestFullscreen();
      }
    }catch(_){}
    updateHUD();
  }

  function startGame(doFullscreen){
    if(started) return;
    started = true;
    statusText.textContent = "running";
    startOverlay.classList.remove("show");
    startOverlay.setAttribute("aria-hidden","true");
    if(doFullscreen) requestFS();
  }

  window.addEventListener("keydown", (e) => {
    if(isMobile()) return;
    const k = e.key;

    if(!started){
      if(k === "Enter"){ e.preventDefault(); startGame(false); return; }
      if(k.toLowerCase() === "f"){ e.preventDefault(); startGame(true); return; }
    }

    if(k.toLowerCase() === "p"){ e.preventDefault(); setPaused(!paused); return; }
    if(k.toLowerCase() === "r"){ e.preventDefault(); if(started) restart(); return; }
    if(k.toLowerCase() === "c"){ e.preventDefault(); ritual(); return; }
    if(k === " "){ e.preventDefault(); ritual(); return; }

    if(paused || gameOver || !started) return;

    if(k === "ArrowLeft"){ e.preventDefault(); move(-1,0); }
    else if(k === "ArrowRight"){ e.preventDefault(); move(1,0); }
    else if(k === "ArrowDown"){ e.preventDefault(); softDrop(); }
    else if(k === "ArrowUp"){ e.preventDefault(); rotatePiece(); }
  }, {passive:false});

  resumeBtn.addEventListener("click", () => setPaused(false));
  restartBtn.addEventListener("click", () => { if(!started) startGame(false); restart(); });
  fsBtn.addEventListener("click", () => requestFS());

  startBtn.addEventListener("click", () => { if(isMobile()) return; startGame(false); });
  startFsBtn.addEventListener("click", () => { if(isMobile()) return; startGame(true); });

  document.addEventListener("fullscreenchange", () => {
    document.documentElement.classList.toggle("fs", !!document.fullscreenElement);
    updateHUD();
  });

  function enforceDesktopGate(){
    const mobile = isMobile();
    desktopOnly.style.display = mobile ? "flex" : "none";
    if(mobile){
      statusText.textContent = "desktop only";
      startOverlay.classList.add("show");
    }else{
      statusText.textContent = started ? (paused ? "paused" : "running") : "idle";
    }
  }

  buildBoard();
  current = spawnPiece();
  next = spawnPiece();
  nextPieceEl.textContent = next.emoji;
  for(let i=0;i<10 && collides(current);i++) current = spawnPiece();
  ritualMatches = findMatchesN(MATCH_N);
  updateHUD();
  enforceDesktopGate();
  window.addEventListener("resize", enforceDesktopGate);
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
